# Kruskal's Minimum Spanning Tree (MST) Algorithm using Greedy Method

class Graph:
    def __init__(self, vertices):
        self.V = vertices  # Number of vertices
        self.graph = []    # List to store all edges (u, v, weight)

    # Function to add an edge
    def add_edge(self, u, v, w):
        self.graph.append([u, v, w])

    # Function to find the set of an element i (with path compression)
    def find(self, parent, i):
        if parent[i] != i:
            parent[i] = self.find(parent, parent[i])
        return parent[i]

    # Function to perform union of two sets
    def union(self, parent, rank, x, y):
        xroot = self.find(parent, x)
        yroot = self.find(parent, y)

        # Attach smaller rank tree under root of high rank tree
        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1

    # Function to construct MST using Kruskalâ€™s algorithm
    def kruskal_mst(self):
        result = []  # Store the final MST
        i = 0  # Index variable for sorted edges
        e = 0  # Count of edges included in result

        # Step 1: Sort all edges by ascending weight
        self.graph = sorted(self.graph, key=lambda item: item[2])

        parent = []
        rank = []

        # Step 2: Create V subsets with single elements
        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        # Number of edges to be taken is V-1
        while e < self.V - 1:
            # Step 3: Pick the smallest edge and increment index
            u, v, w = self.graph[i]
            i += 1
            x = self.find(parent, u)
            y = self.find(parent, v)

            # Step 4: If including this edge doesnâ€™t cause a cycle
            if x != y:
                e += 1
                result.append([u, v, w])
                self.union(parent, rank, x, y)

        # Print the final MST
        print("\nEdges in the constructed Minimum Spanning Tree:")
        total_weight = 0
        for u, v, weight in result:
            print(f"{u} -- {v} == {weight}")
            total_weight += weight
        print("Minimum Cost of Spanning Tree:", total_weight)


# --- MAIN PROGRAM ---

print("Kruskal's Minimum Spanning Tree Algorithm (Greedy Approach)\n")

# Number of vertices
V = int(input("Enter the number of vertices: "))

# Create graph object
g = Graph(V)

# Number of edges
E = int(input("Enter the number of edges: "))

print("Enter each edge in format: u v weight")
for i in range(E):
    u, v, w = map(int, input(f"Edge {i+1}: ").split())
    g.add_edge(u, v, w)

# Run Kruskal's MST algorithm
g.kruskal_mst()



# output
Enter the number of vertices: 4
Enter the number of edges: 5
Enter each edge in format: u v weight
Edge 1: 0 1 10
Edge 2: 0 2 6
Edge 3: 0 3 5
Edge 4: 1 3 15
Edge 5: 2 3 4


Kruskal's Minimum Spanning Tree Algorithm (Greedy Approach)

Edges in the constructed Minimum Spanning Tree:
2 -- 3 == 4
0 -- 3 == 5
0 -- 1 == 10
Minimum Cost of Spanning Tree: 19


ðŸ§  Explanation

Kruskalâ€™s Algorithm Steps (Greedy Strategy):

Sort all edges by weight (ascending order).

Pick the smallest edge that doesnâ€™t form a cycle.

Repeat until you have (V â€“ 1) edges in the MST.

Greedy choice: Always pick the edge with the minimum possible weight that doesnâ€™t form a cycle.

Cycle check: Performed using the Union-Find (Disjoint Set Union) method.

ðŸ’¡ Key Features

Greedy algorithm â†’ chooses minimum weight edge each step.

Time complexity â†’ O(E log E) due to sorting.

Space complexity â†’ O(V) for disjoint set arrays.

Works for any connected, undirected, weighted graph.


